{
  "version": 3,
  "sources": ["../../three/examples/jsm/materials/MeshPostProcessingMaterial.js"],
  "sourcesContent": ["import { MeshPhysicalMaterial } from 'three';\n\n/**\n * The aim of this mesh material is to use information from a post processing pass in the diffuse color pass.\n * This material is based on the MeshPhysicalMaterial.\n *\n * In the current state, only the information of a screen space AO pass can be used in the material.\n * Actually, the output of any screen space AO (SSAO, GTAO) can be used,\n * as it is only necessary to provide the AO in one color channel of a texture,\n * however the AO pass must be rendered prior to the color pass,\n * which makes the post-processing pass somewhat of a pre-processing pass.\n * Fot this purpose a new map (`aoPassMap`) is added to the material.\n * The value of the map is used the same way as the `aoMap` value.\n *\n * Motivation to use the outputs AO pass directly in the material:\n * The incident light of a fragment is composed of ambient light, direct light and indirect light\n * Ambient Occlusion only occludes ambient light and environment light, but not direct light.\n * Direct light is only occluded by geometry that casts shadows.\n * And of course the emitted light should not be darkened by ambient occlusion either.\n * This cannot be achieved if the AO post processing pass is simply blended with the diffuse render pass.\n *\n * Further extension work might be to use the output of an SSR pass or an HBIL pass from a previous frame.\n * This would then create the possibility of SSR and IR depending on material properties such as `roughness`, `metalness` and `reflectivity`.\n**/\n\nclass MeshPostProcessingMaterial extends MeshPhysicalMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tconst aoPassMap = parameters.aoPassMap;\n\t\tconst aoPassMapScale = parameters.aoPassMapScale || 1.0;\n\t\tdelete parameters.aoPassMap;\n\t\tdelete parameters.aoPassMapScale;\n\n\t\tsuper( parameters );\n\n\t\tthis.onBeforeCompile = this._onBeforeCompile;\n\t\tthis.customProgramCacheKey = this._customProgramCacheKey;\n\t\tthis._aoPassMap = aoPassMap;\n\t\tthis.aoPassMapScale = aoPassMapScale;\n\t\tthis._shader = null;\n\n\t}\n\n\tget aoPassMap() {\n\n\t\treturn this._aoPassMap;\n\n\t}\n\n\tset aoPassMap( aoPassMap ) {\n\n\t\tthis._aoPassMap = aoPassMap;\n\t\tthis.needsUpdate = true;\n\t\tthis._setUniforms();\n\n\t}\n\n\t_customProgramCacheKey() {\n\n\t\treturn this._aoPassMap !== undefined && this._aoPassMap !== null ? 'aoPassMap' : '';\n\n\t}\n\n\t_onBeforeCompile( shader ) {\n\n\t\tthis._shader = shader;\n\n\t\tif ( this._aoPassMap !== undefined && this._aoPassMap !== null ) {\n\n\t\t\tshader.fragmentShader = shader.fragmentShader.replace(\n\t\t\t\t'#include <aomap_pars_fragment>',\n\t\t\t\taomap_pars_fragment_replacement\n\t\t\t);\n\t\t\tshader.fragmentShader = shader.fragmentShader.replace(\n\t\t\t\t'#include <aomap_fragment>',\n\t\t\t\taomap_fragment_replacement\n\t\t\t);\n\n\t\t}\n\n\t\tthis._setUniforms();\n\n\t}\n\n\t_setUniforms() {\n\n\t\tif ( this._shader ) {\n\n\t\t\tthis._shader.uniforms.tAoPassMap = { value: this._aoPassMap };\n\t\t\tthis._shader.uniforms.aoPassMapScale = { value: this.aoPassMapScale };\n\n\t\t}\n\n\t}\n\n}\n\nconst aomap_pars_fragment_replacement = /* glsl */`\n#ifdef USE_AOMAP\n\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n\n#endif\n\n\tuniform sampler2D tAoPassMap;\n\tuniform float aoPassMapScale;\n`;\n\nconst aomap_fragment_replacement = /* glsl */`\n#ifndef AOPASSMAP_SWIZZLE\n\t#define AOPASSMAP_SWIZZLE r\n#endif\n\tfloat ambientOcclusion = texelFetch( tAoPassMap, ivec2( gl_FragCoord.xy * aoPassMapScale ), 0 ).AOPASSMAP_SWIZZLE;\n\n#ifdef USE_AOMAP\n\n\t// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tambientOcclusion = min( ambientOcclusion, texture2D( aoMap, vAoMapUv ).r );\n\tambientOcclusion *= ( ambientOcclusion - 1.0 ) * aoMapIntensity + 1.0;\n\n#endif\n\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\n\t#endif\n`;\n\nexport { MeshPostProcessingMaterial };\n"],
  "mappings": ";;;;;;AAyBA,IAAM,6BAAN,cAAyC,qBAAqB;AAAA,EAE7D,YAAa,YAAa;AAEzB,UAAM,YAAY,WAAW;AAC7B,UAAM,iBAAiB,WAAW,kBAAkB;AACpD,WAAO,WAAW;AAClB,WAAO,WAAW;AAElB,UAAO,UAAW;AAElB,SAAK,kBAAkB,KAAK;AAC5B,SAAK,wBAAwB,KAAK;AAClC,SAAK,aAAa;AAClB,SAAK,iBAAiB;AACtB,SAAK,UAAU;AAAA,EAEhB;AAAA,EAEA,IAAI,YAAY;AAEf,WAAO,KAAK;AAAA,EAEb;AAAA,EAEA,IAAI,UAAW,WAAY;AAE1B,SAAK,aAAa;AAClB,SAAK,cAAc;AACnB,SAAK,aAAa;AAAA,EAEnB;AAAA,EAEA,yBAAyB;AAExB,WAAO,KAAK,eAAe,UAAa,KAAK,eAAe,OAAO,cAAc;AAAA,EAElF;AAAA,EAEA,iBAAkB,QAAS;AAE1B,SAAK,UAAU;AAEf,QAAK,KAAK,eAAe,UAAa,KAAK,eAAe,MAAO;AAEhE,aAAO,iBAAiB,OAAO,eAAe;AAAA,QAC7C;AAAA,QACA;AAAA,MACD;AACA,aAAO,iBAAiB,OAAO,eAAe;AAAA,QAC7C;AAAA,QACA;AAAA,MACD;AAAA,IAED;AAEA,SAAK,aAAa;AAAA,EAEnB;AAAA,EAEA,eAAe;AAEd,QAAK,KAAK,SAAU;AAEnB,WAAK,QAAQ,SAAS,aAAa,EAAE,OAAO,KAAK,WAAW;AAC5D,WAAK,QAAQ,SAAS,iBAAiB,EAAE,OAAO,KAAK,eAAe;AAAA,IAErE;AAAA,EAED;AAED;AAEA,IAAM;AAAA;AAAA,EAA4C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYlD,IAAM;AAAA;AAAA,EAAuC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;",
  "names": []
}
